{"version":3,"sources":["node_modules/diff/dist/diff.js","content.js"],"names":["global","factory","exports","module","define","amd","self","Diff","buildValues","diff","components","newString","oldString","useLongestToken","componentPos","componentLen","length","newPos","oldPos","component","removed","value","join","slice","count","added","tmp","map","i","oldValue","lastComponent","equals","pop","prototype","options","arguments","undefined","callback","done","setTimeout","castInput","removeEmpty","tokenize","newLen","oldLen","editLength","maxEditLength","bestPath","extractCommon","execEditLength","diagonalPath","basePath","addPath","removePath","_oldPos","canAdd","canRemove","path","pushComponent","clonePath","exec","ret","last","push","commonCount","left","right","comparator","ignoreCase","toLowerCase","array","split","chars","characterDiff","generateOptions","defaults","name","hasOwnProperty","extendedWordChars","reWhitespace","wordDiff","ignoreWhitespace","test","tokens","splice","lineDiff","diffLines","oldStr","newStr","retLines","linesAndNewlines","line","newlineIsToken","trim","sentenceDiff","cssDiff","_typeof","obj","Symbol","iterator","constructor","_toConsumableArray","arr","_arrayWithoutHoles","Array","isArray","_arrayLikeToArray","_iterableToArray","iter","Object","from","_unsupportedIterableToArray","o","minLen","n","toString","call","_nonIterableSpread","TypeError","len","arr2","objectPrototypeToString","jsonDiff","canonicalize","stack","replacementStack","replacer","key","canonicalizedObj","toJSON","sortedKeys","_key","sort","_this$options","undefinedReplacement","_this$options$stringi","stringifyReplacer","k","v","JSON","stringify","replace","arrayDiff","parsePatch","uniDiff","diffstr","delimiters","match","list","parseIndex","index","header","parseFileHeader","hunks","_line","parseHunk","strict","Error","fileHeader","keyPrefix","data","fileName","substr","chunkHeaderIndex","chunkHeader","hunk","oldStart","oldLines","newStart","newLines","lines","linedelimiters","addCount","removeCount","indexOf","operation","distanceIterator","start","minLine","maxLine","wantForward","backwardExhausted","forwardExhausted","localOffset","applyPatch","source","removeEOFNL","addEOFNL","compareLine","lineNumber","patchContent","errorCount","fuzzFactor","offset","hunkFits","toPos","j","content","diffOffset","_i","_hunk","_toPos","delimiter","previousOperation","_k","structuredPatch","oldFileName","newFileName","oldHeader","newHeader","context","contextLines","entry","oldRangeStart","newRangeStart","curRange","oldLine","newLine","_loop","current","_curRange","prev","apply","_curRange2","_curRange3","contextSize","Math","min","oldEOFNewline","newEOFNewline","noNlBeforeAdds","createTwoFilesPatch","formatPatch","arrayStartsWith","calcLineCount","_calcOldNewLineCount","calcOldNewLineCount","forEach","myCount","mine","theirCount","theirs","loadPatch","param","base","fileNameChanged","patch","selectField","conflict","hunkBefore","check","cloneHunk","mergeLines","mineOffset","mineLines","theirOffset","theirLines","their","insertLeading","mineCurrent","theirCurrent","_hunk$lines","collectChange","_hunk$lines2","removal","mutualChange","insertTrailing","myChanges","a","b","theirChanges","allRemoves","_hunk$lines3","_hunk$lines4","skipRemoveSuperset","_hunk$lines5","swap","_hunk$lines6","collectContext","state","matchChanges","changes","merged","matchIndex","contextChanges","conflicted","change","insert","reduce","removeChanges","delta","changeContent","applyPatches","currentIndex","processIndex","complete","loadFile","err","updatedContent","patched","convertChangesToDMP","convertChangesToXML","s","escapeHTML","createPatch","diffArrays","oldArr","newArr","diffChars","diffCss","diffJson","oldObj","newObj","diffSentences","diffTrimmedLines","diffWords","diffWordsWithSpace","merge","mineIndex","theirsIndex","theirsOffset","Infinity","theirsCurrent","mergedHunk","defineProperty","require","listURL","chrome","runtime","getURL","_diff","html1","html2","result","analize","currentHTML","document","all","outerHTML","Number","MAX_VALUE","site","html","atob","minDiff","console","log","$","ready","get","then"],"mappings":"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","file":"content.js","sourceRoot":"..\\..","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = global || self, factory(global.Diff = {}));\n}(this, (function (exports) { 'use strict';\n\n  function Diff() {}\n  Diff.prototype = {\n    diff: function diff(oldString, newString) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var callback = options.callback;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      this.options = options;\n      var self = this;\n\n      function done(value) {\n        if (callback) {\n          setTimeout(function () {\n            callback(undefined, value);\n          }, 0);\n          return true;\n        } else {\n          return value;\n        }\n      } // Allow subclasses to massage the input prior to running\n\n\n      oldString = this.castInput(oldString);\n      newString = this.castInput(newString);\n      oldString = this.removeEmpty(this.tokenize(oldString));\n      newString = this.removeEmpty(this.tokenize(newString));\n      var newLen = newString.length,\n          oldLen = oldString.length;\n      var editLength = 1;\n      var maxEditLength = newLen + oldLen;\n      var bestPath = [{\n        newPos: -1,\n        components: []\n      }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n        // Identity per the equality and tokenizer\n        return done([{\n          value: this.join(newString),\n          count: newString.length\n        }]);\n      } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n      function execEditLength() {\n        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n          var basePath = void 0;\n\n          var addPath = bestPath[diagonalPath - 1],\n              removePath = bestPath[diagonalPath + 1],\n              _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n          if (addPath) {\n            // No one else is going to attempt to use this value, clear it\n            bestPath[diagonalPath - 1] = undefined;\n          }\n\n          var canAdd = addPath && addPath.newPos + 1 < newLen,\n              canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\n          if (!canAdd && !canRemove) {\n            // If this path is a terminal then prune\n            bestPath[diagonalPath] = undefined;\n            continue;\n          } // Select the diagonal that we want to branch from. We select the prior\n          // path whose position in the new string is the farthest from the origin\n          // and does not pass the bounds of the diff graph\n\n\n          if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n            basePath = clonePath(removePath);\n            self.pushComponent(basePath.components, undefined, true);\n          } else {\n            basePath = addPath; // No need to clone, we've pulled it from the list\n\n            basePath.newPos++;\n            self.pushComponent(basePath.components, true, undefined);\n          }\n\n          _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n\n          if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n            return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n          } else {\n            // Otherwise track this path as a potential candidate and continue.\n            bestPath[diagonalPath] = basePath;\n          }\n        }\n\n        editLength++;\n      } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n      // sync and async mode which is never fun. Loops over execEditLength until a value\n      // is produced.\n\n\n      if (callback) {\n        (function exec() {\n          setTimeout(function () {\n            // This should not happen, but we want to be safe.\n\n            /* istanbul ignore next */\n            if (editLength > maxEditLength) {\n              return callback();\n            }\n\n            if (!execEditLength()) {\n              exec();\n            }\n          }, 0);\n        })();\n      } else {\n        while (editLength <= maxEditLength) {\n          var ret = execEditLength();\n\n          if (ret) {\n            return ret;\n          }\n        }\n      }\n    },\n    pushComponent: function pushComponent(components, added, removed) {\n      var last = components[components.length - 1];\n\n      if (last && last.added === added && last.removed === removed) {\n        // We need to clone here as the component clone operation is just\n        // as shallow array clone\n        components[components.length - 1] = {\n          count: last.count + 1,\n          added: added,\n          removed: removed\n        };\n      } else {\n        components.push({\n          count: 1,\n          added: added,\n          removed: removed\n        });\n      }\n    },\n    extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n      var newLen = newString.length,\n          oldLen = oldString.length,\n          newPos = basePath.newPos,\n          oldPos = newPos - diagonalPath,\n          commonCount = 0;\n\n      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n        newPos++;\n        oldPos++;\n        commonCount++;\n      }\n\n      if (commonCount) {\n        basePath.components.push({\n          count: commonCount\n        });\n      }\n\n      basePath.newPos = newPos;\n      return oldPos;\n    },\n    equals: function equals(left, right) {\n      if (this.options.comparator) {\n        return this.options.comparator(left, right);\n      } else {\n        return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n      }\n    },\n    removeEmpty: function removeEmpty(array) {\n      var ret = [];\n\n      for (var i = 0; i < array.length; i++) {\n        if (array[i]) {\n          ret.push(array[i]);\n        }\n      }\n\n      return ret;\n    },\n    castInput: function castInput(value) {\n      return value;\n    },\n    tokenize: function tokenize(value) {\n      return value.split('');\n    },\n    join: function join(chars) {\n      return chars.join('');\n    }\n  };\n\n  function buildValues(diff, components, newString, oldString, useLongestToken) {\n    var componentPos = 0,\n        componentLen = components.length,\n        newPos = 0,\n        oldPos = 0;\n\n    for (; componentPos < componentLen; componentPos++) {\n      var component = components[componentPos];\n\n      if (!component.removed) {\n        if (!component.added && useLongestToken) {\n          var value = newString.slice(newPos, newPos + component.count);\n          value = value.map(function (value, i) {\n            var oldValue = oldString[oldPos + i];\n            return oldValue.length > value.length ? oldValue : value;\n          });\n          component.value = diff.join(value);\n        } else {\n          component.value = diff.join(newString.slice(newPos, newPos + component.count));\n        }\n\n        newPos += component.count; // Common case\n\n        if (!component.added) {\n          oldPos += component.count;\n        }\n      } else {\n        component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n        oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n        // The diffing algorithm is tied to add then remove output and this is the simplest\n        // route to get the desired output with minimal overhead.\n\n        if (componentPos && components[componentPos - 1].added) {\n          var tmp = components[componentPos - 1];\n          components[componentPos - 1] = components[componentPos];\n          components[componentPos] = tmp;\n        }\n      }\n    } // Special case handle for when one terminal is ignored (i.e. whitespace).\n    // For this case we merge the terminal into the prior string and drop the change.\n    // This is only available for string mode.\n\n\n    var lastComponent = components[componentLen - 1];\n\n    if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n      components[componentLen - 2].value += lastComponent.value;\n      components.pop();\n    }\n\n    return components;\n  }\n\n  function clonePath(path) {\n    return {\n      newPos: path.newPos,\n      components: path.components.slice(0)\n    };\n  }\n\n  var characterDiff = new Diff();\n  function diffChars(oldStr, newStr, options) {\n    return characterDiff.diff(oldStr, newStr, options);\n  }\n\n  function generateOptions(options, defaults) {\n    if (typeof options === 'function') {\n      defaults.callback = options;\n    } else if (options) {\n      for (var name in options) {\n        /* istanbul ignore else */\n        if (options.hasOwnProperty(name)) {\n          defaults[name] = options[name];\n        }\n      }\n    }\n\n    return defaults;\n  }\n\n  //\n  // Ranges and exceptions:\n  // Latin-1 Supplement, 0080–00FF\n  //  - U+00D7  × Multiplication sign\n  //  - U+00F7  ÷ Division sign\n  // Latin Extended-A, 0100–017F\n  // Latin Extended-B, 0180–024F\n  // IPA Extensions, 0250–02AF\n  // Spacing Modifier Letters, 02B0–02FF\n  //  - U+02C7  ˇ &#711;  Caron\n  //  - U+02D8  ˘ &#728;  Breve\n  //  - U+02D9  ˙ &#729;  Dot Above\n  //  - U+02DA  ˚ &#730;  Ring Above\n  //  - U+02DB  ˛ &#731;  Ogonek\n  //  - U+02DC  ˜ &#732;  Small Tilde\n  //  - U+02DD  ˝ &#733;  Double Acute Accent\n  // Latin Extended Additional, 1E00–1EFF\n\n  var extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\n  var reWhitespace = /\\S/;\n  var wordDiff = new Diff();\n\n  wordDiff.equals = function (left, right) {\n    if (this.options.ignoreCase) {\n      left = left.toLowerCase();\n      right = right.toLowerCase();\n    }\n\n    return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n  };\n\n  wordDiff.tokenize = function (value) {\n    // All whitespace symbols except newline group into one token, each newline - in separate token\n    var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\n    for (var i = 0; i < tokens.length - 1; i++) {\n      // If we have an empty string in the next field and we have only word chars before and after, merge\n      if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n        tokens[i] += tokens[i + 2];\n        tokens.splice(i + 1, 2);\n        i--;\n      }\n    }\n\n    return tokens;\n  };\n\n  function diffWords(oldStr, newStr, options) {\n    options = generateOptions(options, {\n      ignoreWhitespace: true\n    });\n    return wordDiff.diff(oldStr, newStr, options);\n  }\n  function diffWordsWithSpace(oldStr, newStr, options) {\n    return wordDiff.diff(oldStr, newStr, options);\n  }\n\n  var lineDiff = new Diff();\n\n  lineDiff.tokenize = function (value) {\n    var retLines = [],\n        linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n      linesAndNewlines.pop();\n    } // Merge the content and line separators into single tokens\n\n\n    for (var i = 0; i < linesAndNewlines.length; i++) {\n      var line = linesAndNewlines[i];\n\n      if (i % 2 && !this.options.newlineIsToken) {\n        retLines[retLines.length - 1] += line;\n      } else {\n        if (this.options.ignoreWhitespace) {\n          line = line.trim();\n        }\n\n        retLines.push(line);\n      }\n    }\n\n    return retLines;\n  };\n\n  function diffLines(oldStr, newStr, callback) {\n    return lineDiff.diff(oldStr, newStr, callback);\n  }\n  function diffTrimmedLines(oldStr, newStr, callback) {\n    var options = generateOptions(callback, {\n      ignoreWhitespace: true\n    });\n    return lineDiff.diff(oldStr, newStr, options);\n  }\n\n  var sentenceDiff = new Diff();\n\n  sentenceDiff.tokenize = function (value) {\n    return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n  };\n\n  function diffSentences(oldStr, newStr, callback) {\n    return sentenceDiff.diff(oldStr, newStr, callback);\n  }\n\n  var cssDiff = new Diff();\n\n  cssDiff.tokenize = function (value) {\n    return value.split(/([{}:;,]|\\s+)/);\n  };\n\n  function diffCss(oldStr, newStr, callback) {\n    return cssDiff.diff(oldStr, newStr, callback);\n  }\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n  }\n\n  function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var objectPrototypeToString = Object.prototype.toString;\n  var jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\n  jsonDiff.useLongestToken = true;\n  jsonDiff.tokenize = lineDiff.tokenize;\n\n  jsonDiff.castInput = function (value) {\n    var _this$options = this.options,\n        undefinedReplacement = _this$options.undefinedReplacement,\n        _this$options$stringi = _this$options.stringifyReplacer,\n        stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {\n      return typeof v === 'undefined' ? undefinedReplacement : v;\n    } : _this$options$stringi;\n    return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n  };\n\n  jsonDiff.equals = function (left, right) {\n    return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n  };\n\n  function diffJson(oldObj, newObj, options) {\n    return jsonDiff.diff(oldObj, newObj, options);\n  } // This function handles the presence of circular references by bailing out when encountering an\n  // object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\n  function canonicalize(obj, stack, replacementStack, replacer, key) {\n    stack = stack || [];\n    replacementStack = replacementStack || [];\n\n    if (replacer) {\n      obj = replacer(key, obj);\n    }\n\n    var i;\n\n    for (i = 0; i < stack.length; i += 1) {\n      if (stack[i] === obj) {\n        return replacementStack[i];\n      }\n    }\n\n    var canonicalizedObj;\n\n    if ('[object Array]' === objectPrototypeToString.call(obj)) {\n      stack.push(obj);\n      canonicalizedObj = new Array(obj.length);\n      replacementStack.push(canonicalizedObj);\n\n      for (i = 0; i < obj.length; i += 1) {\n        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n      }\n\n      stack.pop();\n      replacementStack.pop();\n      return canonicalizedObj;\n    }\n\n    if (obj && obj.toJSON) {\n      obj = obj.toJSON();\n    }\n\n    if (_typeof(obj) === 'object' && obj !== null) {\n      stack.push(obj);\n      canonicalizedObj = {};\n      replacementStack.push(canonicalizedObj);\n\n      var sortedKeys = [],\n          _key;\n\n      for (_key in obj) {\n        /* istanbul ignore else */\n        if (obj.hasOwnProperty(_key)) {\n          sortedKeys.push(_key);\n        }\n      }\n\n      sortedKeys.sort();\n\n      for (i = 0; i < sortedKeys.length; i += 1) {\n        _key = sortedKeys[i];\n        canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n      }\n\n      stack.pop();\n      replacementStack.pop();\n    } else {\n      canonicalizedObj = obj;\n    }\n\n    return canonicalizedObj;\n  }\n\n  var arrayDiff = new Diff();\n\n  arrayDiff.tokenize = function (value) {\n    return value.slice();\n  };\n\n  arrayDiff.join = arrayDiff.removeEmpty = function (value) {\n    return value;\n  };\n\n  function diffArrays(oldArr, newArr, callback) {\n    return arrayDiff.diff(oldArr, newArr, callback);\n  }\n\n  function parsePatch(uniDiff) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n        delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n        list = [],\n        i = 0;\n\n    function parseIndex() {\n      var index = {};\n      list.push(index); // Parse diff metadata\n\n      while (i < diffstr.length) {\n        var line = diffstr[i]; // File header found, end parsing diff metadata\n\n        if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n          break;\n        } // Diff index\n\n\n        var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n        if (header) {\n          index.index = header[1];\n        }\n\n        i++;\n      } // Parse file headers if they are defined. Unified diff requires them, but\n      // there's no technical issues to have an isolated hunk without file header\n\n\n      parseFileHeader(index);\n      parseFileHeader(index); // Parse hunks\n\n      index.hunks = [];\n\n      while (i < diffstr.length) {\n        var _line = diffstr[i];\n\n        if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n          break;\n        } else if (/^@@/.test(_line)) {\n          index.hunks.push(parseHunk());\n        } else if (_line && options.strict) {\n          // Ignore unexpected content unless in strict mode\n          throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n        } else {\n          i++;\n        }\n      }\n    } // Parses the --- and +++ headers, if none are found, no lines\n    // are consumed.\n\n\n    function parseFileHeader(index) {\n      var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n      if (fileHeader) {\n        var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n        var data = fileHeader[2].split('\\t', 2);\n        var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n        if (/^\".*\"$/.test(fileName)) {\n          fileName = fileName.substr(1, fileName.length - 2);\n        }\n\n        index[keyPrefix + 'FileName'] = fileName;\n        index[keyPrefix + 'Header'] = (data[1] || '').trim();\n        i++;\n      }\n    } // Parses a hunk\n    // This assumes that we are at the start of a hunk.\n\n\n    function parseHunk() {\n      var chunkHeaderIndex = i,\n          chunkHeaderLine = diffstr[i++],\n          chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n      var hunk = {\n        oldStart: +chunkHeader[1],\n        oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n        newStart: +chunkHeader[3],\n        newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n        lines: [],\n        linedelimiters: []\n      }; // Unified Diff Format quirk: If the chunk size is 0,\n      // the first number is one lower than one would expect.\n      // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n      if (hunk.oldLines === 0) {\n        hunk.oldStart += 1;\n      }\n\n      if (hunk.newLines === 0) {\n        hunk.newStart += 1;\n      }\n\n      var addCount = 0,\n          removeCount = 0;\n\n      for (; i < diffstr.length; i++) {\n        // Lines starting with '---' could be mistaken for the \"remove line\" operation\n        // But they could be the header for the next file. Therefore prune such cases out.\n        if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n          break;\n        }\n\n        var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n        if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n          hunk.lines.push(diffstr[i]);\n          hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n          if (operation === '+') {\n            addCount++;\n          } else if (operation === '-') {\n            removeCount++;\n          } else if (operation === ' ') {\n            addCount++;\n            removeCount++;\n          }\n        } else {\n          break;\n        }\n      } // Handle the empty block count case\n\n\n      if (!addCount && hunk.newLines === 1) {\n        hunk.newLines = 0;\n      }\n\n      if (!removeCount && hunk.oldLines === 1) {\n        hunk.oldLines = 0;\n      } // Perform optional sanity checking\n\n\n      if (options.strict) {\n        if (addCount !== hunk.newLines) {\n          throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n        }\n\n        if (removeCount !== hunk.oldLines) {\n          throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n        }\n      }\n\n      return hunk;\n    }\n\n    while (i < diffstr.length) {\n      parseIndex();\n    }\n\n    return list;\n  }\n\n  // Iterator that traverses in the range of [min, max], stepping\n  // by distance from a given start position. I.e. for [0, 4], with\n  // start of 2, this will iterate 2, 3, 1, 4, 0.\n  function distanceIterator (start, minLine, maxLine) {\n    var wantForward = true,\n        backwardExhausted = false,\n        forwardExhausted = false,\n        localOffset = 1;\n    return function iterator() {\n      if (wantForward && !forwardExhausted) {\n        if (backwardExhausted) {\n          localOffset++;\n        } else {\n          wantForward = false;\n        } // Check if trying to fit beyond text length, and if not, check it fits\n        // after offset location (or desired location on first iteration)\n\n\n        if (start + localOffset <= maxLine) {\n          return localOffset;\n        }\n\n        forwardExhausted = true;\n      }\n\n      if (!backwardExhausted) {\n        if (!forwardExhausted) {\n          wantForward = true;\n        } // Check if trying to fit before text beginning, and if not, check it fits\n        // before offset location\n\n\n        if (minLine <= start - localOffset) {\n          return -localOffset++;\n        }\n\n        backwardExhausted = true;\n        return iterator();\n      } // We tried to fit hunk before text beginning and beyond text length, then\n      // hunk can't fit on the text. Return undefined\n\n    };\n  }\n\n  function applyPatch(source, uniDiff) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (typeof uniDiff === 'string') {\n      uniDiff = parsePatch(uniDiff);\n    }\n\n    if (Array.isArray(uniDiff)) {\n      if (uniDiff.length > 1) {\n        throw new Error('applyPatch only works with a single input.');\n      }\n\n      uniDiff = uniDiff[0];\n    } // Apply the diff to the input\n\n\n    var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n        delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n        hunks = uniDiff.hunks,\n        compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\n      return line === patchContent;\n    },\n        errorCount = 0,\n        fuzzFactor = options.fuzzFactor || 0,\n        minLine = 0,\n        offset = 0,\n        removeEOFNL,\n        addEOFNL;\n    /**\n     * Checks if the hunk exactly fits on the provided location\n     */\n\n\n    function hunkFits(hunk, toPos) {\n      for (var j = 0; j < hunk.lines.length; j++) {\n        var line = hunk.lines[j],\n            operation = line.length > 0 ? line[0] : ' ',\n            content = line.length > 0 ? line.substr(1) : line;\n\n        if (operation === ' ' || operation === '-') {\n          // Context sanity check\n          if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n            errorCount++;\n\n            if (errorCount > fuzzFactor) {\n              return false;\n            }\n          }\n\n          toPos++;\n        }\n      }\n\n      return true;\n    } // Search best fit offsets for each hunk based on the previous ones\n\n\n    for (var i = 0; i < hunks.length; i++) {\n      var hunk = hunks[i],\n          maxLine = lines.length - hunk.oldLines,\n          localOffset = 0,\n          toPos = offset + hunk.oldStart - 1;\n      var iterator = distanceIterator(toPos, minLine, maxLine);\n\n      for (; localOffset !== undefined; localOffset = iterator()) {\n        if (hunkFits(hunk, toPos + localOffset)) {\n          hunk.offset = offset += localOffset;\n          break;\n        }\n      }\n\n      if (localOffset === undefined) {\n        return false;\n      } // Set lower text limit to end of the current hunk, so next ones don't try\n      // to fit over already patched text\n\n\n      minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n    } // Apply patch hunks\n\n\n    var diffOffset = 0;\n\n    for (var _i = 0; _i < hunks.length; _i++) {\n      var _hunk = hunks[_i],\n          _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\n      diffOffset += _hunk.newLines - _hunk.oldLines;\n\n      for (var j = 0; j < _hunk.lines.length; j++) {\n        var line = _hunk.lines[j],\n            operation = line.length > 0 ? line[0] : ' ',\n            content = line.length > 0 ? line.substr(1) : line,\n            delimiter = _hunk.linedelimiters[j];\n\n        if (operation === ' ') {\n          _toPos++;\n        } else if (operation === '-') {\n          lines.splice(_toPos, 1);\n          delimiters.splice(_toPos, 1);\n          /* istanbul ignore else */\n        } else if (operation === '+') {\n          lines.splice(_toPos, 0, content);\n          delimiters.splice(_toPos, 0, delimiter);\n          _toPos++;\n        } else if (operation === '\\\\') {\n          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\n          if (previousOperation === '+') {\n            removeEOFNL = true;\n          } else if (previousOperation === '-') {\n            addEOFNL = true;\n          }\n        }\n      }\n    } // Handle EOFNL insertion/removal\n\n\n    if (removeEOFNL) {\n      while (!lines[lines.length - 1]) {\n        lines.pop();\n        delimiters.pop();\n      }\n    } else if (addEOFNL) {\n      lines.push('');\n      delimiters.push('\\n');\n    }\n\n    for (var _k = 0; _k < lines.length - 1; _k++) {\n      lines[_k] = lines[_k] + delimiters[_k];\n    }\n\n    return lines.join('');\n  } // Wrapper that supports multiple file patches via callbacks.\n\n  function applyPatches(uniDiff, options) {\n    if (typeof uniDiff === 'string') {\n      uniDiff = parsePatch(uniDiff);\n    }\n\n    var currentIndex = 0;\n\n    function processIndex() {\n      var index = uniDiff[currentIndex++];\n\n      if (!index) {\n        return options.complete();\n      }\n\n      options.loadFile(index, function (err, data) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        var updatedContent = applyPatch(data, index, options);\n        options.patched(index, updatedContent, function (err) {\n          if (err) {\n            return options.complete(err);\n          }\n\n          processIndex();\n        });\n      });\n    }\n\n    processIndex();\n  }\n\n  function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    if (!options) {\n      options = {};\n    }\n\n    if (typeof options.context === 'undefined') {\n      options.context = 4;\n    }\n\n    var diff = diffLines(oldStr, newStr, options);\n    diff.push({\n      value: '',\n      lines: []\n    }); // Append an empty value to make cleanup easier\n\n    function contextLines(lines) {\n      return lines.map(function (entry) {\n        return ' ' + entry;\n      });\n    }\n\n    var hunks = [];\n    var oldRangeStart = 0,\n        newRangeStart = 0,\n        curRange = [],\n        oldLine = 1,\n        newLine = 1;\n\n    var _loop = function _loop(i) {\n      var current = diff[i],\n          lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n      current.lines = lines;\n\n      if (current.added || current.removed) {\n        var _curRange;\n\n        // If we have previous context, start with that\n        if (!oldRangeStart) {\n          var prev = diff[i - 1];\n          oldRangeStart = oldLine;\n          newRangeStart = newLine;\n\n          if (prev) {\n            curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n            oldRangeStart -= curRange.length;\n            newRangeStart -= curRange.length;\n          }\n        } // Output our changes\n\n\n        (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {\n          return (current.added ? '+' : '-') + entry;\n        }))); // Track the updated file position\n\n\n        if (current.added) {\n          newLine += lines.length;\n        } else {\n          oldLine += lines.length;\n        }\n      } else {\n        // Identical context lines. Track line changes\n        if (oldRangeStart) {\n          // Close out any changes that have been output (or join overlapping)\n          if (lines.length <= options.context * 2 && i < diff.length - 2) {\n            var _curRange2;\n\n            // Overlapping\n            (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n          } else {\n            var _curRange3;\n\n            // end the range and output\n            var contextSize = Math.min(lines.length, options.context);\n\n            (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n\n            var hunk = {\n              oldStart: oldRangeStart,\n              oldLines: oldLine - oldRangeStart + contextSize,\n              newStart: newRangeStart,\n              newLines: newLine - newRangeStart + contextSize,\n              lines: curRange\n            };\n\n            if (i >= diff.length - 2 && lines.length <= options.context) {\n              // EOF is inside this hunk\n              var oldEOFNewline = /\\n$/.test(oldStr);\n              var newEOFNewline = /\\n$/.test(newStr);\n              var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n\n              if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n                // special case: old has no eol and no trailing context; no-nl can end up before adds\n                // however, if the old file is empty, do not output the no-nl line\n                curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n              }\n\n              if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n                curRange.push('\\\\ No newline at end of file');\n              }\n            }\n\n            hunks.push(hunk);\n            oldRangeStart = 0;\n            newRangeStart = 0;\n            curRange = [];\n          }\n        }\n\n        oldLine += lines.length;\n        newLine += lines.length;\n      }\n    };\n\n    for (var i = 0; i < diff.length; i++) {\n      _loop(i);\n    }\n\n    return {\n      oldFileName: oldFileName,\n      newFileName: newFileName,\n      oldHeader: oldHeader,\n      newHeader: newHeader,\n      hunks: hunks\n    };\n  }\n  function formatPatch(diff) {\n    var ret = [];\n\n    if (diff.oldFileName == diff.newFileName) {\n      ret.push('Index: ' + diff.oldFileName);\n    }\n\n    ret.push('===================================================================');\n    ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n    ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n    for (var i = 0; i < diff.hunks.length; i++) {\n      var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n      // the first number is one lower than one would expect.\n      // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n      if (hunk.oldLines === 0) {\n        hunk.oldStart -= 1;\n      }\n\n      if (hunk.newLines === 0) {\n        hunk.newStart -= 1;\n      }\n\n      ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n      ret.push.apply(ret, hunk.lines);\n    }\n\n    return ret.join('\\n') + '\\n';\n  }\n  function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n  }\n  function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n  }\n\n  function arrayEqual(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    return arrayStartsWith(a, b);\n  }\n  function arrayStartsWith(array, start) {\n    if (start.length > array.length) {\n      return false;\n    }\n\n    for (var i = 0; i < start.length; i++) {\n      if (start[i] !== array[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function calcLineCount(hunk) {\n    var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\n        oldLines = _calcOldNewLineCount.oldLines,\n        newLines = _calcOldNewLineCount.newLines;\n\n    if (oldLines !== undefined) {\n      hunk.oldLines = oldLines;\n    } else {\n      delete hunk.oldLines;\n    }\n\n    if (newLines !== undefined) {\n      hunk.newLines = newLines;\n    } else {\n      delete hunk.newLines;\n    }\n  }\n  function merge(mine, theirs, base) {\n    mine = loadPatch(mine, base);\n    theirs = loadPatch(theirs, base);\n    var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n    // Leaving sanity checks on this to the API consumer that may know more about the\n    // meaning in their own context.\n\n    if (mine.index || theirs.index) {\n      ret.index = mine.index || theirs.index;\n    }\n\n    if (mine.newFileName || theirs.newFileName) {\n      if (!fileNameChanged(mine)) {\n        // No header or no change in ours, use theirs (and ours if theirs does not exist)\n        ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n        ret.newFileName = theirs.newFileName || mine.newFileName;\n        ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n        ret.newHeader = theirs.newHeader || mine.newHeader;\n      } else if (!fileNameChanged(theirs)) {\n        // No header or no change in theirs, use ours\n        ret.oldFileName = mine.oldFileName;\n        ret.newFileName = mine.newFileName;\n        ret.oldHeader = mine.oldHeader;\n        ret.newHeader = mine.newHeader;\n      } else {\n        // Both changed... figure it out\n        ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n        ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n        ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n        ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n      }\n    }\n\n    ret.hunks = [];\n    var mineIndex = 0,\n        theirsIndex = 0,\n        mineOffset = 0,\n        theirsOffset = 0;\n\n    while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n      var mineCurrent = mine.hunks[mineIndex] || {\n        oldStart: Infinity\n      },\n          theirsCurrent = theirs.hunks[theirsIndex] || {\n        oldStart: Infinity\n      };\n\n      if (hunkBefore(mineCurrent, theirsCurrent)) {\n        // This patch does not overlap with any of the others, yay.\n        ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n        mineIndex++;\n        theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n      } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n        // This patch does not overlap with any of the others, yay.\n        ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n        theirsIndex++;\n        mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n      } else {\n        // Overlap, merge as best we can\n        var mergedHunk = {\n          oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n          oldLines: 0,\n          newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n          newLines: 0,\n          lines: []\n        };\n        mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n        theirsIndex++;\n        mineIndex++;\n        ret.hunks.push(mergedHunk);\n      }\n    }\n\n    return ret;\n  }\n\n  function loadPatch(param, base) {\n    if (typeof param === 'string') {\n      if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n        return parsePatch(param)[0];\n      }\n\n      if (!base) {\n        throw new Error('Must provide a base reference or pass in a patch');\n      }\n\n      return structuredPatch(undefined, undefined, base, param);\n    }\n\n    return param;\n  }\n\n  function fileNameChanged(patch) {\n    return patch.newFileName && patch.newFileName !== patch.oldFileName;\n  }\n\n  function selectField(index, mine, theirs) {\n    if (mine === theirs) {\n      return mine;\n    } else {\n      index.conflict = true;\n      return {\n        mine: mine,\n        theirs: theirs\n      };\n    }\n  }\n\n  function hunkBefore(test, check) {\n    return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n  }\n\n  function cloneHunk(hunk, offset) {\n    return {\n      oldStart: hunk.oldStart,\n      oldLines: hunk.oldLines,\n      newStart: hunk.newStart + offset,\n      newLines: hunk.newLines,\n      lines: hunk.lines\n    };\n  }\n\n  function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n    // This will generally result in a conflicted hunk, but there are cases where the context\n    // is the only overlap where we can successfully merge the content here.\n    var mine = {\n      offset: mineOffset,\n      lines: mineLines,\n      index: 0\n    },\n        their = {\n      offset: theirOffset,\n      lines: theirLines,\n      index: 0\n    }; // Handle any leading content\n\n    insertLeading(hunk, mine, their);\n    insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n    while (mine.index < mine.lines.length && their.index < their.lines.length) {\n      var mineCurrent = mine.lines[mine.index],\n          theirCurrent = their.lines[their.index];\n\n      if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n        // Both modified ...\n        mutualChange(hunk, mine, their);\n      } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n        var _hunk$lines;\n\n        // Mine inserted\n        (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n      } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n        var _hunk$lines2;\n\n        // Theirs inserted\n        (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n      } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n        // Mine removed or edited\n        removal(hunk, mine, their);\n      } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n        // Their removed or edited\n        removal(hunk, their, mine, true);\n      } else if (mineCurrent === theirCurrent) {\n        // Context identity\n        hunk.lines.push(mineCurrent);\n        mine.index++;\n        their.index++;\n      } else {\n        // Context mismatch\n        conflict(hunk, collectChange(mine), collectChange(their));\n      }\n    } // Now push anything that may be remaining\n\n\n    insertTrailing(hunk, mine);\n    insertTrailing(hunk, their);\n    calcLineCount(hunk);\n  }\n\n  function mutualChange(hunk, mine, their) {\n    var myChanges = collectChange(mine),\n        theirChanges = collectChange(their);\n\n    if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n      // Special case for remove changes that are supersets of one another\n      if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n        var _hunk$lines3;\n\n        (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n\n        return;\n      } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n        var _hunk$lines4;\n\n        (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n\n        return;\n      }\n    } else if (arrayEqual(myChanges, theirChanges)) {\n      var _hunk$lines5;\n\n      (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n\n      return;\n    }\n\n    conflict(hunk, myChanges, theirChanges);\n  }\n\n  function removal(hunk, mine, their, swap) {\n    var myChanges = collectChange(mine),\n        theirChanges = collectContext(their, myChanges);\n\n    if (theirChanges.merged) {\n      var _hunk$lines6;\n\n      (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n    } else {\n      conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n    }\n  }\n\n  function conflict(hunk, mine, their) {\n    hunk.conflict = true;\n    hunk.lines.push({\n      conflict: true,\n      mine: mine,\n      theirs: their\n    });\n  }\n\n  function insertLeading(hunk, insert, their) {\n    while (insert.offset < their.offset && insert.index < insert.lines.length) {\n      var line = insert.lines[insert.index++];\n      hunk.lines.push(line);\n      insert.offset++;\n    }\n  }\n\n  function insertTrailing(hunk, insert) {\n    while (insert.index < insert.lines.length) {\n      var line = insert.lines[insert.index++];\n      hunk.lines.push(line);\n    }\n  }\n\n  function collectChange(state) {\n    var ret = [],\n        operation = state.lines[state.index][0];\n\n    while (state.index < state.lines.length) {\n      var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n      if (operation === '-' && line[0] === '+') {\n        operation = '+';\n      }\n\n      if (operation === line[0]) {\n        ret.push(line);\n        state.index++;\n      } else {\n        break;\n      }\n    }\n\n    return ret;\n  }\n\n  function collectContext(state, matchChanges) {\n    var changes = [],\n        merged = [],\n        matchIndex = 0,\n        contextChanges = false,\n        conflicted = false;\n\n    while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n      var change = state.lines[state.index],\n          match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n      if (match[0] === '+') {\n        break;\n      }\n\n      contextChanges = contextChanges || change[0] !== ' ';\n      merged.push(match);\n      matchIndex++; // Consume any additions in the other block as a conflict to attempt\n      // to pull in the remaining context after this\n\n      if (change[0] === '+') {\n        conflicted = true;\n\n        while (change[0] === '+') {\n          changes.push(change);\n          change = state.lines[++state.index];\n        }\n      }\n\n      if (match.substr(1) === change.substr(1)) {\n        changes.push(change);\n        state.index++;\n      } else {\n        conflicted = true;\n      }\n    }\n\n    if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n      conflicted = true;\n    }\n\n    if (conflicted) {\n      return changes;\n    }\n\n    while (matchIndex < matchChanges.length) {\n      merged.push(matchChanges[matchIndex++]);\n    }\n\n    return {\n      merged: merged,\n      changes: changes\n    };\n  }\n\n  function allRemoves(changes) {\n    return changes.reduce(function (prev, change) {\n      return prev && change[0] === '-';\n    }, true);\n  }\n\n  function skipRemoveSuperset(state, removeChanges, delta) {\n    for (var i = 0; i < delta; i++) {\n      var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n      if (state.lines[state.index + i] !== ' ' + changeContent) {\n        return false;\n      }\n    }\n\n    state.index += delta;\n    return true;\n  }\n\n  function calcOldNewLineCount(lines) {\n    var oldLines = 0;\n    var newLines = 0;\n    lines.forEach(function (line) {\n      if (typeof line !== 'string') {\n        var myCount = calcOldNewLineCount(line.mine);\n        var theirCount = calcOldNewLineCount(line.theirs);\n\n        if (oldLines !== undefined) {\n          if (myCount.oldLines === theirCount.oldLines) {\n            oldLines += myCount.oldLines;\n          } else {\n            oldLines = undefined;\n          }\n        }\n\n        if (newLines !== undefined) {\n          if (myCount.newLines === theirCount.newLines) {\n            newLines += myCount.newLines;\n          } else {\n            newLines = undefined;\n          }\n        }\n      } else {\n        if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n          newLines++;\n        }\n\n        if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n          oldLines++;\n        }\n      }\n    });\n    return {\n      oldLines: oldLines,\n      newLines: newLines\n    };\n  }\n\n  // See: http://code.google.com/p/google-diff-match-patch/wiki/API\n  function convertChangesToDMP(changes) {\n    var ret = [],\n        change,\n        operation;\n\n    for (var i = 0; i < changes.length; i++) {\n      change = changes[i];\n\n      if (change.added) {\n        operation = 1;\n      } else if (change.removed) {\n        operation = -1;\n      } else {\n        operation = 0;\n      }\n\n      ret.push([operation, change.value]);\n    }\n\n    return ret;\n  }\n\n  function convertChangesToXML(changes) {\n    var ret = [];\n\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n\n      if (change.added) {\n        ret.push('<ins>');\n      } else if (change.removed) {\n        ret.push('<del>');\n      }\n\n      ret.push(escapeHTML(change.value));\n\n      if (change.added) {\n        ret.push('</ins>');\n      } else if (change.removed) {\n        ret.push('</del>');\n      }\n    }\n\n    return ret.join('');\n  }\n\n  function escapeHTML(s) {\n    var n = s;\n    n = n.replace(/&/g, '&amp;');\n    n = n.replace(/</g, '&lt;');\n    n = n.replace(/>/g, '&gt;');\n    n = n.replace(/\"/g, '&quot;');\n    return n;\n  }\n\n  exports.Diff = Diff;\n  exports.applyPatch = applyPatch;\n  exports.applyPatches = applyPatches;\n  exports.canonicalize = canonicalize;\n  exports.convertChangesToDMP = convertChangesToDMP;\n  exports.convertChangesToXML = convertChangesToXML;\n  exports.createPatch = createPatch;\n  exports.createTwoFilesPatch = createTwoFilesPatch;\n  exports.diffArrays = diffArrays;\n  exports.diffChars = diffChars;\n  exports.diffCss = diffCss;\n  exports.diffJson = diffJson;\n  exports.diffLines = diffLines;\n  exports.diffSentences = diffSentences;\n  exports.diffTrimmedLines = diffTrimmedLines;\n  exports.diffWords = diffWords;\n  exports.diffWordsWithSpace = diffWordsWithSpace;\n  exports.merge = merge;\n  exports.parsePatch = parsePatch;\n  exports.structuredPatch = structuredPatch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","const Diff = require('diff')\r\n\r\nvar listURL = chrome.runtime.getURL(\"data/htmls.json\");\r\n\r\n$(document).ready(() => \r\n    $.get(listURL).then(data => analize(data))\r\n)\r\n\r\n\r\nfunction _diff(html1,html2){\r\n    result = Diff.diffLines(html1,html2);\r\n    //convert the json array to a result number\r\n\r\n}\r\n\r\nfunction analize(data){\r\n    \r\n    currentHTML = document.all[0].outerHTML;\r\n    \r\n    let min = { diff:Number.MAX_VALUE , site:undefined };\r\n\r\n    for(let site in data){\r\n\r\n        html = atob(data[site])\r\n        let diff = _diff(html,currentHTML);\r\n        \r\n        if(diff < minDiff)\r\n            min = {diff:diff,site:site};\r\n\r\n    }\r\n\r\n    console.log(`The current page is like ${min.site}. There are ${min.diff} lines different`)\r\n}\r\n\r\n"]}